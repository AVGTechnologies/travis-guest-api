#!/usr/bin/ruby

$: << './lib'
require 'bundler/setup'
require 'travis/guest-api/server'
require 'travis/guest-api/reporter'
require 'travis/support/amqp'

$stdout.sync = true
$stderr.sync = true

def declare_queues
  reporting_channel = Travis::Amqp.connection.create_channel
  builds = reporting_channel.queue("reporting.jobs.builds", :durable => true)
  logs = reporting_channel.queue("reporting.jobs.logs", :durable => true)
  test_results = reporting_channel.queue("reporting.jobs.test_results", :durable => true)

  exchange = Travis::Amqp.connection.create_channel.exchange('reporting', type: 'topic', durable: true)
  builds.bind('reporting', routing_key: 'reporting.jobs.builds')
  logs.bind('reporting', routing_key: 'reporting.jobs.logs')
  test_results.bind('reporting', routing_key: 'reporting.jobs.test_results')
end


Travis::Amqp.config = Travis.config.amqp
Travis::Amqp.connect
declare_queues

options = {
  Port: ENV['GUEST_API_PORT'] || 9292,
  Threads: ENV['GUEST_API_THREADS'] || '0:16'
}
reporter = Travis::GuestApi::Reporter.new(
  'standalone-reporter',
  Travis::Amqp::Publisher.jobs('builds', unique_channel: true, dont_retry: true),
  Travis::Amqp::Publisher.jobs('logs', unique_channel: true, dont_retry: true),
  Travis::Amqp::Publisher.jobs('test_results', unique_channel: true, dont_retry: true)
)

def handle_payload(payload)
  job_id = payload[:job_id]
  case payload[:event]
  when 'finished'
    reporter.send_last_tresult(job_id)
    Travis::GuestApi.cache.delete(job_id)
    Travis.logger.info "Finished job_id=#{job_id}"
  when 'started'
    Travis.logger.info "Started job_id=#{job_id}"
  end
end


server = Travis::GuestApi::Server.new(nil, reporter, options, &method(:handle_payload)).start
Travis.logger.info "Server started"
server.server_thread.join
